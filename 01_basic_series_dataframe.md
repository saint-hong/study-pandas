# Pandas

## 1. 판다스 소개 
- 대부분의 데이터는 시계열과 표로 나타낼 수 있다.
    - 시계열 series
    - 표 table
- 판다스 패키지는 시리즈와 데이터프레임 클래스를 제공한다.

## 2. 시리즈
- `시리즈 클래스 Series Class` : 넘파이의 1차원 배열과 비슷하다. 각각의 데이터를 의미하는 인덱스(Index)를 붙일 수 있다. 데이터 자체는 값(value)이라고 부른다.
    - Series = Value + Index
    
### 2-1. 시리즈 생성하기
- 데이터를 리스트나 1차원 배열 형식으로 Series 클래스 생성자에 넣어준다.
    - **인덱스의 길이가 데이터의 길이와 같아야 한다.** 
    - **인덱스 라벨 : 문자열, 날짜, 시간, 정수 등 가능**
    - 인덱스의 값은 라벨(label)이라고 부르기도 한다.     

#### 리스트에 값을 넣고 클래스 생성자에 넣는다.
- pd.Series([value, value, value], index=["label", "label", "label"])

```python
s = pd.Series([9904312, 3448737, 2890451, 2466052],
              index=["서울", "부산", "인천", "대구"])
s

>>> print

서울    9904312
부산    3448737
인천    2890451
대구    2466052
dtype: int64
```
#### 인덱스를 지정하지 않으면 0부터 시작하는 정수값이 입력된다.

```python
pd.Series(range(10, 14))

>>> print

0    10
1    11
2    12
3    13
dtype: int64
```

#### 인덱스와 값에 접근
- index, values 속성 사용

```python
s.index

>>> print

Index(['서울', '부산', '인천', '대구'], dtype='object')

s.values

>>> print

array([9904312, 3448737, 2890451, 2466052], dtype=int64)
```

#### 이름 붙이기
- name 속성을 사용
    - 컬럼명과 같다.
- **index에도 이름을 붙일 수 있다.**
    - index.name

```python
s.name = "인구"
s

>>> print

서울    9904312
부산    3448737
인천    2890451
대구    2466052
Name: 인구, dtype: int64

s.index.name = "도시"
s

>>> print

도시
서울    9904312
부산    3448737
인천    2890451
대구    2466052
Name: 인구, dtype: int64
```

### 2-2. 시리즈의 연산
- 시리즈도 넘파이와 같이 벡터화 연산이 가능하다. 
    - 벡터화 : 열벡터 처럼 인식하여 벡터의 모든 데이터에 연산을 적용하여 계산
    - 시리즈의 값(value)에만 적용된다. 인덱스는 연산 불가

```python
s / 1000000

>>> print

도시
서울    9.904312
부산    3.448737
인천    2.890451
대구    2.466052
Name: 인구, dtype: float64
```

### 2-3. 시리즈 인덱싱
- 시리즈의 인덱싱은 넘파이 배열의 방법과 같으며 추가로 인덱스 라벨을 사용해서 인덱싱 할 수도 있다.
    - 배열 인덱싱이나 인덱스 라벨을 이용한 슬라이싱(slicing)도 가능

```python
s["서울"], s["부산"], s["인천"], s["대구"]

>>> print

(9904312, 3448737, 2890451, 2466052)

s[0], s[1], s[2], s[3]

>>> print

(9904312, 3448737, 2890451, 2466052)
```

#### 배열 인덱싱
- 부분적인 값을 가지는 **시리즈 자료형을 반환**한다.
- 자료의 순서를 바꾸거나 특정한 자료만 선택할 수 있다.
    - 같은 인덱스나 값을 선택할 수 있음

```python
s[[0, 1, 3]]

>>> print

도시
서울    9904312
부산    3448737
대구    2466052
Name: 인구, dtype: int64

s[["서울", "대구", "부산"]]

>>> print

도시
서울    9904312
대구    2466052
부산    3448737
Name: 인구, dtype: int64
```

- 불리언 값을 사용하여 데이터롤 조회할 수 있다.

```python
s[(250e4 < s) & (s < 500e4)]

>>> print

도시
부산    3448737
인천    2890451
Name: 인구, dtype: int64
```

- 숫자 규칙 : e는 소수점의 위치

```python
250e4, 500e4

>>> print

(2500000.0, 5000000.0)
```
#### 슬라이싱
- 부분적인 시리즈 반환
- **문자열 라벨을 사용하면 숫자 인덱싱과 달리 콜론 뒤의 값도 결과에 포함된다.**

```python
s[1:3]

>>> print

도시
부산    3448737
인천    2890451
Name: 인구, dtype: int64
```

- 인덱스의 라벨을 사용하여 슬라이싱 할 수 있다.

```python
s["부산":"대구"]

>>> print

도시
부산    3448737
인천    2890451
대구    2466052
Name: 인구, dtype: int64
```

#### 라벨이 영문인 경우
- 라벨이 영문이면 라벨값을 속성값 처럼 사용하여 값을 불러올 수 있다.
    - 라벨이 한글이어도 속성값 처럼 쓸 수 있다.

```python
s_1 = pd.Series(range(3), index=["a", "b", "c"])
s_1

>>> print

a    0
b    1
c    2
dtype: int64

s_1.a

>>> print

0
```

### 2-4. 시리즈와 딕셔너리 자료형
- 시리즈 객체는 라벨값으로 인덱싱이 가능하다.
    - **라벨 값을 키로 갖는 딕셔너리 자료형**과 같다.
- 딕셔너리 자료형의 연산들 가능
    - in
    - items 매서드와 for를 통해 key, value 값에 접근 할 수 있다.

```python
"서울" in s

>>> print

True

"대전" in s

>>> print

False
```

- for문에 items() 메서드 사용

```python
for k, v in s.items() :
    print("%s = %d" % (k, v))

>>> print

서울 = 9904312
부산 = 3448737
인천 = 2890451
대구 = 2466052
```

#### 딕셔너리 객체를 사용한 시리즈 생성
- 딕셔너리 객체로 시리즈를 만들 수도 있다.
    - **딕셔너리 자체가 순서를 갖지 않으므로 딕셔너리 객체로 시리즈를 만들면 시리즈도 순서를 갖지 않는다.**
    - index를 지정해 주면 된다.
    - index 지정 안하면 딕셔너리의 key 값이 인덱스로 설정된다.

```python
s_2 = pd.Series({"서울":8877665, "부산":8764820, "인천":9987617, "대전":7926372})
s_2

>>> print

서울    8877665
부산    8764820
인천    9987617
대전    7926372
dtype: int64
```

### 2-5. 인덱스 기반 연산
- 시리즈와 시리즈의 연산
- 같은 인덱스가 있는 경우에만 연산을 하고 없으면 NaN을 반환한다.
    - **NaN 값이 반환되면서 자료형이 float64로 바뀐다.**
    - notnull 메서드를 사용하면 자료형을 바꿀 수 있다.

#### 시리즈 객체 통으로 연산하면 nan 반환된다.

```python
ds = s - s_2
ds

>>> print

대구          NaN
대전          NaN
부산    3361101.0
서울    9804440.0
인천    2825019.0
dtype: float64
```

#### 시리즈에서 values를 지정하여 연산하면 nan 반환안된다.
- 같은 인덱스가 없으면 빼는 쪽에서 값을 그대로 가져온다.

```python
s.values - s_2.values

>>> print

array([9816676, 3348865, 2846925, 2400620], dtype=int64)
```

- 결측데이터 확인

```python
ds.notnull()

>>> print

대구    False
대전    False
부산     True
서울     True
인천     True
dtype: bool
```

- 불리언 값을 인덱스로 사용하여 데이터 조회

```python
ds[ds.notnull()]

>>> print

부산    3361101.0
서울    9804440.0
인천    2825019.0
dtype: float64
```

### 2-6. 데이터의 갱신, 추가, 삭제
- 갱신 update

```python
rs["부산"] = 1.63
rs

>>> print

부산       1.630000
서울    9817.005767
인천    4317.488385
dtype: float64
```
- 추가 add

```python
rs["대구"] = 1.41
rs

>>> print

부산       1.630000
서울    9817.005767
인천    4317.488385
대구       1.410000
```
- 삭제 delete

```python
del rs["서울"]

rs

>>> print

부산       1.630000
인천    4317.488385
대구       1.410000
dtype: float64
```

- 인덱스 라벨이 한글이어도 데이터 조회 가능

```python
rs.인천

>>> print

4317.488384888128
```

### 2-5. 연습문제
- 임의로 두개의 시리즈를 만든다. 
- 문자열 인덱스를 갖는다.
- 공통적이지 않은 라벨이 있어야 한다.
- 두 시리즈로 사칙연산을 한다.

```python
s1 = pd.Series([111, 222, 333, 444], index=["a0", "b0", "c0", "d0"])
s2 = pd.Series([102, 203, 304, 405], index=["a0", "b0", "d0", "e0"])

plus = s1 + s2
plus = plus[plus.notnull()]
plus

>>> print

a0    213.0
b0    425.0
d0    748.0
dtype: float64

minus = s1 - s2
minus = minus[minus.notnull()]
minus

>>> print

a0      9.0
b0     19.0
d0    140.0
dtype: float64

divide = s1 / s2
divide = divide[divide.notnull()]
divide

>>> print

a0    1.088235
b0    1.093596
d0    1.460526
dtype: float64

multi = s1 * s2
multi = multi[multi.notnull()]
multi

>>> print

a0     11322.0
b0     45066.0
d0    134976.0
dtype: float64
```

## 3. 데이터프레임 클래스
- Series : 1차원 배열에 행방향으로 인덱스를 붙인 것과 같다. row index
- DataFrame : 2차원 행렬 데이터에 인덱스를 붙인 것과 같다. row, column
    - row index : 행 데이터의 이름
    - column index : 열 인덱스
    - **공통 인덱스를 가지는 열 시리즈를 딕셔너리로 묶어놓은 것이라고 할 수 있다.**

## 4. 데이터프레임 생성
- 데이터프레임을 만드는 방법은 매우 다양하다. 그중에서 간단한 방법
    - 하나의 열이 되는 데이터를 리스트나 일차원 배열을 준비한다.
    - 이 각각의 열에 대한 이름(라벨)을 키로 가지는 딕셔너리를 만든다.
    - 이 데이터를 **DataFrame 클래스 생성자**에 넣는다.
    - 동시에 열방향 인덱스는 columns 인수로, 행방향 인덱스는 index 인수로 지정한다.






























